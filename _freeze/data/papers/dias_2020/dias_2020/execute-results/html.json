{
  "hash": "62022da5b03fa60a514f7bdea6d6573a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Emphasizing Publishers Does Not Effectively Reduce Susceptibility to Misinformation on Social Media.\ndate: \"2020\"\nauthor: \n  - Dias, Nicholas\ncategories:\n  - highlight source\nbibliography: ../../../references.bib\nnocite: |\n  @diasEmphasizingPublishersDoes2020\ndraft: false \n---\n\n\n\n\n\n\n## Reference\n\n::: {#refs}\n:::\n\n## Intervention\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintervention_info <- tibble(\n    intervention_description = 'Study 1: In the control condition, participants saw Facebook-like news posts, with the source domain shwon in gray text. Two treatment conditions: in one the logo of publisher outlet was shown in a bright banner (logo banner); in the other no source was shown (neither gray text, nor logo banner). Study 2: Like study 1, but without the \"no source\" condition.',\n    control_format = \"facebook\",\n    control_selection = \"facebook\",\n    control_selection_description = \"For Study 1, we will use the Facebook like condition (facebook) and NOT the condition without a source (no_source) as a control group, since it matches the control group of Study 2, is more comparable with other studies\\' control groups, and is closer to real-world settings.\",\n    originally_identified_treatment_effect = FALSE)\n\n# display\nshow_conditions(intervention_info)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> intervention_description </th>\n   <th style=\"text-align:left;\"> control_selection_description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Study 1: In the control condition, participants saw Facebook-like news posts, with the source domain shwon in gray text. Two treatment conditions: in one the logo of publisher outlet was shown in a bright banner (logo banner); in the other no source was shown (neither gray text, nor logo banner). Study 2: Like study 1, but without the &quot;no source&quot; condition. </td>\n   <td style=\"text-align:left;\"> For Study 1, we will use the Facebook like condition (facebook) and NOT the condition without a source (no_source) as a control group, since it matches the control group of Study 2, is more comparable with other studies' control groups, and is closer to real-world settings. </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n\n### Notes\n\nStudies 3, 4 and 5 are not relevant, as participants did not provide accuracy ratings, but instead rated the trustworthiness of different sources. Study 6 would in principle be relevant, as it tests an intervention of showcasing the source. However, other than in Studies 1 and 2, in the baseline control condition of Study 6, the text of the news headline was presented in isolation, i.e. plain text and no a source. The treatment effect here is thus not highlighting a source, but adding a source in the first place. Since many other studies use a facebook format where the source is present, and since this format is more realistic in real-world context, we prefer using this as a baseline. We therefore exclude Study 6. \n\nSomething that is weird: In Study 1, there is a slightly reduced number of WorkerIDs than there are ResponseIDs, suggesting that some individuals might have taken the survey several times (see below). In Study 2, there is no ResponseID variable, but in the original wide format data there is also one more completed study (i.e. line) than individual WorkerIDs (see below).\n\nTo err on the side of caution, we exclude all WorkerIDs with multiple survey takes. \n\n## Data Cleaning\n\n### Study 1\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- read_csv(\"dias_2020-study_1.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 1890 Columns: 445\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (16): ResponseID, ResponseSet, Name, IPAddress, StartDate, EndDate, Wor...\ndbl (427): Condition, Status, StartDateNum, Finished, confirmCode, IDInst, I...\nlgl   (2): ExternalDataReference, Email\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 445\n  Condition ResponseID   ResponseSet Name  ExternalDataReference Email IPAddress\n      <dbl> <chr>        <chr>       <chr> <lgl>                 <lgl> <chr>    \n1         2 R_1NfzxXhNc… Default Re… Anon… NA                    NA    75.91.73…\n2         2 R_ektOPVZf7… Default Re… Anon… NA                    NA    64.22.25…\n3         2 R_uyrfrfz7c… Default Re… Anon… NA                    NA    76.5.191…\n4         2 R_cBcEMRtkk… Default Re… Anon… NA                    NA    172.76.4…\n5         1 R_2Vs7jWOlP… Default Re… Anon… NA                    NA    67.251.1…\n6         2 R_2coorehCL… Default Re… Anon… NA                    NA    73.255.2…\n# ℹ 438 more variables: Status <dbl>, StartDate <chr>, StartDateNum <dbl>,\n#   EndDate <chr>, Finished <dbl>, confirmCode <dbl>, WorkerID <chr>,\n#   IDInst <dbl>, Inst <dbl>, Fake1_S <dbl>, Fake1_2 <dbl>, Fake1_3 <dbl>,\n#   Fake1_RT_1 <dbl>, Fake1_RT_2 <dbl>, Fake1_RT_3 <dbl>, Fake1_RT_4 <dbl>,\n#   Fake2_S <dbl>, Fake2_2 <dbl>, Fake2_3 <dbl>, Fake2_RT_1 <dbl>,\n#   Fake2_RT_2 <dbl>, Fake2_RT_3 <dbl>, Fake2_RT_4 <dbl>, Fake3_S <dbl>,\n#   Fake3_2 <dbl>, Fake3_3 <dbl>, Fake3_RT_1 <dbl>, Fake3_RT_2 <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n#### `accuracy_raw`, `veracity`\n\nThere is no documentation. But from the stata code the authors provide, we know that: \n\n- Columns ending in `_2` (like Fake1_2 or Real1_2) represent accuracy ratings made by participants for each news item.\n\n- Real and Fake in the titles refer to whether the news item was true (real) or **false (fake`).\n\nWe bring the data into long format and build an accuracy outcome column.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gather the wide columns into long format\nd_long <- d |>\n  # Reshape long just for _2 (accuracy) and _3 (sharing)\n  pivot_longer(\n    cols = matches(\"^(Real|Fake)\\\\d+_(2|3)$\"),\n    names_to = c(\"veracity\", \"item\", \"measure\"),\n    names_pattern = \"^(Real|Fake)(\\\\d+)_([23])$\"\n  ) |>\n  mutate(\n    measure = recode(measure, `2` = \"accuracy\", `3` = \"sharing\")  # rename 2/3\n  ) |>\n  pivot_wider(names_from = measure, values_from = value) |> \n  rename(accuracy_raw = accuracy)\n```\n:::\n\n\n\n\nWe code the veracity variable. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(\n    veracity = if_else(veracity == \"Fake\", \"false\", \"true\")\n    ) \n```\n:::\n\n\n\n\n#### `scale`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(d_long$accuracy_raw, useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n    1     2     3     4  <NA> \n 7913  5807  6537  2068 23035 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |>\n  mutate(scale = 4)\n```\n:::\n\n\n\n\n#### Conditions (`intervention_label`, `control_label`, `condition`)\n\nFrom the stata code we can conclude that in Study 1, the conditions are `no_source` (coded as 1), `facebook` (coded 2), `highlight_banner` (coded as 3). In study 2, the conditions are coded as `facebook` (coded 1), `highlight_banner` (coded as 2).\n\nWe code the condition variable. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |>\n  mutate(\n    intervention_label = case_when(\n      Condition == 3 ~ \"highlight_banner\",\n      TRUE ~ NA_character_\n    ),\n    control_label = case_when(\n      Condition == 1 ~ \"no_source\",\n      Condition == 2 ~ \"facebook\",\n      TRUE ~ NA_character_\n    ),\n    condition = if_else(Condition == 3, \"treatment\", \"control\")\n  )\n```\n:::\n\n\n\n\n\n#### `news_id`\n\nWe have previously coded `item`, but this is not yet a unique item identifier--these numbers only identify items within each veracity category.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long |> \n  group_by(veracity) |> \n  summarise(n_distinct(item))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  veracity `n_distinct(item)`\n  <chr>                 <int>\n1 false                    12\n2 true                     12\n```\n\n\n:::\n:::\n\n\n\n\nFor our news identifier, we therefore combine the veracity variable with these identifiers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(news_id = paste0(veracity, \"_\", item))\n```\n:::\n\n\n\n\n#### `age`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(age = Age\n         )\n```\n:::\n\n\n\n\n#### `year`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(year = year(mdy(StartDate))\n         )\n```\n:::\n\n\n\n\n#### Identifiers (`subject_id`, `experiment_id`) & removing respondents with mutliple surveys\n\nThe original wide format data had 1890 lines, i.e. completed studies. First, we get an overview of candidate variables for participant identifiers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long |> \n  summarize(n_distinct(ResponseID),\n            n_distinct(WorkerID))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  `n_distinct(ResponseID)` `n_distinct(WorkerID)`\n                     <int>                  <int>\n1                     1890                   1845\n```\n\n\n:::\n:::\n\n\n\n\nIt seems like the same workers have in some cases done the survey mulitple times. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long |> \n  group_by(WorkerID) |> \n  summarise(n_surveys_taken = n_distinct(ResponseID), \n            n_different_start_dates = n_distinct(StartDate)) |> \n  filter(n_surveys_taken > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   WorkerID       n_surveys_taken n_different_start_dates\n   <chr>                    <int>                   <int>\n 1 A1B2GXPMA7YONT              35                       1\n 2 A1BL5TRC3DHOHD               2                       1\n 3 A1BWO4ZG5OB68S               2                       1\n 4 A26DD205RQG4UA               2                       1\n 5 A2I88USJQLNT2K               2                       1\n 6 A2XVOYY8BDEZXF               2                       2\n 7 A3ESURUKHP67K6               2                       1\n 8 A3TRL4MZMGU22S               2                       1\n 9 A3ZRS4RUCH2OO                2                       2\n10 A9T9UBZBWFZTL                2                       1\n11 AC777GHVJ8U45                2                       1\n12 AUU9JZS6MIQ7C                2                       1\n```\n\n\n:::\n:::\n\n\n\nIn particular, one worker took the survey 35 times. Unfortunately, we don't know about the exact time, we only get the day of the survey taken (otherwise we could select the first survey occurence). Not knowing what has been going on there, we will exclude these participants.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long_remove_doubles <- d_long |>\n  group_by(WorkerID) |>\n  filter(n_distinct(ResponseID) == 1) |>\n  ungroup()\n\n# check \nn_distinct(d_long_remove_doubles$WorkerID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1833\n```\n\n\n:::\n\n```{.r .cell-code}\n# check \nn_distinct(d_long$WorkerID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1845\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- d_long_remove_doubles |> \n  mutate(subject_id = WorkerID, \n         experiment_id = 1) \n```\n:::\n\n\n\n\n\n### Study 2\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- read_csv(\"dias_2020-study_2.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 563 Columns: 602\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (14): Party_TEXT, IPAddress, StartDate, EndDate, WorkerID, Comments, Le...\ndbl (588): Condition, Fake, Real, Fake_C, Real_C, Fake_L, Real_L, Fake_PC, F...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 602\n  Condition  Fake  Real Fake_C Real_C Fake_L Real_L Fake_PC Fake_nPC Real_PC\n      <dbl> <dbl> <dbl>  <dbl>  <dbl>  <dbl>  <dbl>   <dbl>    <dbl>   <dbl>\n1         1  1.25  1.17   1      1      1.5    1.33    1.5      1       1.33\n2         1  1.67  2.17   1.5    2      1.83   2.33    1.83     1.5     2.33\n3         1  1.75  3.08   1.33   2.83   2.17   3.33    2.17     1.33    3.33\n4         1  1.25  2.42   1      3      1.5    1.83    1.5      1       1.83\n5         1  1.17  3.17   1      2.83   1.33   3.5     1.33     1       3.5 \n6         1  1.58  2      1.33   2      1.83   2       1.83     1.33    2   \n# ℹ 592 more variables: Real_nPC <dbl>, Discernment <dbl>, C_Discernment <dbl>,\n#   L_Discernment <dbl>, PC_Discernment <dbl>, nPC_Discernment <dbl>,\n#   CRT_split <dbl>, ClintonTrump <dbl>, Media_Leaders <dbl>, Media_Bias <dbl>,\n#   Fake_SM <dbl>, Real_SM <dbl>, Fake_SM_C <dbl>, Real_SM_C <dbl>,\n#   Fake_SM_L <dbl>, Real_SM_L <dbl>, Fake_SM_PC <dbl>, Fake_SM_nPC <dbl>,\n#   Real_SM_PC <dbl>, Real_SM_nPC <dbl>, SocialMedia_Chk <dbl>, CRT_ACC <dbl>,\n#   CRT_Rand <dbl>, CRT_Thomson <dbl>, Age <dbl>, Sex <dbl>, Education <dbl>, …\n```\n\n\n:::\n:::\n\n\n\n\n#### `accuracy_raw`, `veracity`\n\nThere is no documentation. But from the stata code the authors provide, we know that: \n\n- Columns ending in `_2` (like Fake1_2 or Real1_2) represent accuracy ratings made by participants for each news item.\n\n- Real and Fake in the titles refer to whether the news item was true (real) or **false (fake`).\n\nWe bring the data into long format and build an accuracy outcome column.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Gather the wide columns into long format\nd_long <- d |>\n  # Reshape long just for _2 (accuracy) and _3 (sharing)\n  pivot_longer(\n    cols = matches(\"^(Real|Fake)\\\\d+_(2|3)$\"),\n    names_to = c(\"veracity\", \"item\", \"measure\"),\n    names_pattern = \"^(Real|Fake)(\\\\d+)_([23])$\"\n  ) |>\n  mutate(\n    measure = recode(measure, `2` = \"accuracy\", `3` = \"sharing\")  # rename 2/3\n  ) |>\n  pivot_wider(names_from = measure, values_from = value) |> \n  rename(accuracy_raw = accuracy)\n```\n:::\n\n\n\n\nWe code the veracity variable. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(\n    veracity = if_else(veracity == \"Fake\", \"false\", \"true\")\n    ) \n```\n:::\n\n\n\n\n#### `scale`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(d_long$accuracy_raw, useNA = \"always\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n   1    2    3    4 <NA> \n1701 1083 1282  489 8957 \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |>\n  mutate(scale = 4)\n```\n:::\n\n\n\n\n#### Conditions (`intervention_label`, `control_label`, `condition`)\n\nIn study 2, the conditions are coded as `facebook` (coded 1), `highlight_banner` (coded as 2).\n\nWe code the condition variable. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |>\n  mutate(\n    intervention_label = case_when(\n      Condition == 2 ~ \"highlight_banner\",\n      TRUE ~ NA_character_\n    ),\n    control_label = case_when(\n      Condition == 1 ~ \"facebook\",\n      TRUE ~ NA_character_\n    ),\n    condition = if_else(Condition == 2, \"treatment\", \"control\")\n  )\n```\n:::\n\n\n\n\n#### `news_id`\n\nWe have previously coded `item`, but this is not yet a unique item identifier--these numbers only identify items within each veracity category.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long |> \n  group_by(veracity) |> \n  summarise(n_distinct(item))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  veracity `n_distinct(item)`\n  <chr>                 <int>\n1 false                    12\n2 true                     12\n```\n\n\n:::\n:::\n\n\n\n\nFor our news identifier, we therefore combine the veracity variable with these identifiers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(news_id = paste0(veracity, \"_\", item))\n```\n:::\n\n\n\n\n#### `age`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(age = Age\n         )\n```\n:::\n\n\n\n\n#### `year`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long <- d_long |> \n  mutate(year = year(mdy(StartDate))\n         )\n```\n:::\n\n\n\n\n#### Identifiers (`subject_id`, `experiment_id`) & removing respondents with mutliple surveys\n\nThe original wide format data had 563 lines, i.e. completed studies. There is one worker with two surveys, which we will exclude. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd |> \n  group_by(WorkerID) |> \n  summarise(n_surveys_taken = n(), \n            n_different_start_dates = n_distinct(StartDate)) |> \n  filter(n_surveys_taken > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  WorkerID       n_surveys_taken n_different_start_dates\n  <chr>                    <int>                   <int>\n1 A15LHHN76OW2UM               2                       1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd_long_remove_doubles <- d_long |>\n  filter(WorkerID != \"A15LHHN76OW2UM\")\n\n# check \nn_distinct(d_long_remove_doubles$WorkerID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 561\n```\n\n\n:::\n\n```{.r .cell-code}\n# check \nn_distinct(d_long$WorkerID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 562\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 <- d_long_remove_doubles |> \n  mutate(subject_id = WorkerID, \n         experiment_id = 2) \n```\n:::\n\n\n\n\n### Combine Studies\n\n#### Combine and add identifiers (`country`, `paper_id`)\n\nWe combine both studies. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Combine + add remaining variables\ndias_2020 <- bind_rows(d1, d2) |> \n  mutate(country = \"United States\",\n         paper_id = \"dias_2020\") |> \n  # add_intervention_info \n  bind_cols(intervention_info) |> \n  select(any_of(target_variables))\n```\n:::\n\n\n\n\n#### Additional news identifiers (`recycled_news`, `recycled_news_reference`)\n\nSince in both studies the same news headlines have been used (with the same labels), we can just keep the labels. We add where the headlines have been taken from. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Combine + add remaining variables\ndias_2020 <- dias_2020 |> \n  mutate(recycled_news = TRUE, \n         recycled_news_reference = \"Pennycook, G., Bear, A., Collins, E. T., & Rand, D. G. (2020). The Implied Truth Effect: Attaching Warnings to a Subset of Fake News Headlines Increases Perceived Accuracy of Headlines Without Warnings. Management Science, 66(11), 4944–4957. https://doi.org/10.1287/mnsc.2019.3478\") \n```\n:::\n\n\n\n\n#### `news_selection`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Combine + add remaining variables\ndias_2020 <- dias_2020 |> \n  mutate(news_selection = \"researchers\") \n```\n:::\n\n\n\n\n## Write out data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave_data(dias_2020)\n```\n:::\n",
    "supporting": [
      "dias_2020_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}